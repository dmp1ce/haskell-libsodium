module TestHelpers where

import qualified Data.Text as T
import Test.QuickCheck
import Foreign.C.Types
import Numeric
import Data.Bits

convertEndian :: [a] -> [a]
convertEndian (x1:x2:xs) = (convertEndian xs) ++ [x1,x2]
convertEndian xs = xs

-- | Useful for trimming Hexadecimal 'Text' for testing equality
trim0s :: T.Text -> T.Text
trim0s = T.dropAround ('0'==)

isHexEqual :: String -> String -> Bool
isHexEqual x y = (trim0s $ T.pack x) == (trim0s $ T.pack y)

-- | Pad hex generated by 'showHex' if required
padHex :: String -> String
padHex s = if odd $ length s then '0':s else s


-- Quickcheck Arbirary modifiers
genSafeChar :: Gen Char
genSafeChar = elements ['a'..'z']

genSafeString :: Gen String
genSafeString = listOf genSafeChar

newtype SafeString = SafeString { unwrapSafeString :: String }
    deriving Show

instance Arbitrary SafeString where
    arbitrary = SafeString <$> genSafeString

showHexCUCharList :: [CUChar] -> String
showHexCUCharList cs = concatMap (padHex . (flip showHex "")) cs

convertCUCharListToWord :: [CUChar] -> Word
convertCUCharListToWord cs
  | length cs > 8 = error "CUChar list is too long"
  | otherwise     = foldr (\cu ac -> (toEnum $ fromEnum cu) + (shiftL ac 8))
                      0 $ reverse cs
